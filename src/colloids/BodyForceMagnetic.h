
// This file is part of HemeLB and is Copyright (C)
// the HemeLB team and/or their institutions, as detailed in the
// file AUTHORS. This software is provided under the terms of the
// license in the file LICENSE.

#ifndef HEMELB_COLLOIDS_MAGNETICBODYFORCE_H
#define HEMELB_COLLOIDS_MAGNETICBODYFORCE_H

#include "colloids/BodyForces.h"

namespace hemelb
{
	namespace colloids
	{
		class MagneticBodyForce : public BodyForce
		{
			public:
				static BodyForce* ReadFromXml(io::xml::Element& xml)
				{
					LatticeForceVector magneticMoment;
					LatticePosition position;

					io::xml::Element positionElem = xml.GetChildOrThrow("position");
					positionElem.GetAttributeOrThrow("x", position.x);
					positionElem.GetAttributeOrThrow("y", position.y);
					positionElem.GetAttributeOrThrow("z", position.z);

					io::xml::Element magneticMomentElem = xml.GetChildOrThrow("magneticMoment");
					magneticMomentElem.GetAttributeOrThrow("x", magneticMoment.x);
					magneticMomentElem.GetAttributeOrThrow("y", magneticMoment.y);
					magneticMomentElem.GetAttributeOrThrow("z", magneticMoment.z);

					return new MagneticBodyForce(magneticMoment, position);
				};

				virtual const LatticeForceVector GetForceForParticle(const Particle& particle) const
				{
					// radius of particle
					PhysicalDistance radius = particle.GetRadius(true);
					// connector between dipole and particle
					PhysicalPosition connector;
					connector  = particle.GetGlobalPosition()-position;
					connector *= particle.GetVoxelSize();

					// diameter of particle
					PhysicalDistance diameter   = 2.0*radius;
					// magnitude of connector, i.e. distance
					PhysicalDistance separation = connector.GetMagnitude();

					// the magnetic field generated by big dipole at particle location
					util::Vector3D<PhysicalForce> magneticMoment1 = -(magneticMoment/pow(separation,2)
							-connector*3.0*magneticMoment.Dot(connector)
							/pow(separation,5));
					magneticMoment1 *= /*1.0/(4.0*PI)*prefactor*/(radius*radius*radius)*chi/3.0;

					util::Vector3D<PhysicalForce> bodyForce;
					util::Vector3D<PhysicalForce> term0;
					util::Vector3D<PhysicalForce> term1;
					util::Vector3D<PhysicalForce> term2;
					util::Vector3D<PhysicalForce> term3;

					term0  = magneticMoment1;
					term0 *= magneticMoment.Dot(connector);

					term1  = magneticMoment;
					term1 *= magneticMoment1.Dot(connector);

					term2  = connector;
					term2 *= magneticMoment.Dot(magneticMoment1);

					term3  = connector;
					term3 *= (5.0*magneticMoment.Dot(connector)*magneticMoment1.Dot(connector))/pow(separation,2);

					bodyForce  = term0+term1+term2-term3;
					bodyForce *= mu_0/
						(prefactor*pow(separation,5));

					return bodyForce;
				};

			protected:
				MagneticBodyForce(const LatticeForceVector magneticMoment, const LatticePosition position) :
					magneticMoment(magneticMoment), position(position) {};

				const LatticeForceVector magneticMoment;
				const LatticePosition position;
		};

		class MagneticBodyForceFactory : public BodyForceFactory<MagneticBodyForce> { };
	}
}
#endif /* HEMELB_COLLOIDS_MAGNETICBODYFORCE_H */
